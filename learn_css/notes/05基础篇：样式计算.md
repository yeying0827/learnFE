## 基础篇：样式计算（优先级、相对单位）

作为一名开发者，在看到设计图就应本能地在脑海中组织好大概的`CSS代码`用于排版与布局网页。

但在编写样式时可能会遇到以下情况：

* `样式覆盖`导致排版错位甚至乱套
* 布局时不知使用什么长度单位声明属性
* 引入第三方`UI框架`导致自定义样式失效
* 同一节点同时出现多种类型样式时不知如何优雅解决



### 优先级别（权重）

在编写`CSS`时，使用不同选择器选中相同节点且为相同属性声明不同值，就会发生`样式覆盖`。

发生`样式覆盖`时，应用哪个样式就由选择器的优先级别决定，因此`样式覆盖`的根本原因是未处理好规则间的优先级别。虽然使用`!important`能解决问题，但不能什么情况都由`!important`暴力解决。

通过相关规范分配给规则一个权重，那样式可根据权重计算，呈现网页最终效果。

#### 特性

优先级别具备以下特性：

* **就近原则**：后出现的样式其优先级别比先出现的样式更高

* **继承样式**：优先级别最低

* **!important样式**：优先级别最高，若冲突则重新计算

* **引入权重**：内联样式 > 内嵌样式 > 外部样式 > 导入样式

  * 内联样式

    指在`HTML标签`中使用`style`声明样式，是最简单粗暴的样式声明方式。

    通常不推荐这样声明样式，它会导致`HTML结构`变得不纯净且体积变大，不利于`SEO`，也不利于后期维护。

    ```html
    <p style="color: #f66;">
      I am JowayYoung
    </p>
    ```

  * 内嵌样式

    指在`<head>`中使用`<style>`声明样式。

    通常在开发环境中使用，比如`webpack`使用`style-loader`就是将代码中的样式全部提取出来，以该方式声明网页样式。

    若多个网页使用公共样式，就要重复声明，网页数量越多就越难维护，当然网页样式较少的情况下还是使用该方式最好。

    ```html
    <head>
      <style>
        p {
          color: #f66;
        }
      </style>
    </head>
    ```

  * 外部样式

    指在`<head>`中使用`<link`>引入样式，是最方便快捷的样式声明方式。

    通常在生产环境中使用，这样方便将`HTML代码`与`CSS代码`完全分离，为`HTML语义化`与`结构与表现完全分离`提供技术上的支持。

    这样的处理不仅利于开发也利于维护，同时也是团队协作的最优`CSS代码`组织方式。

    ```html
    <head>
      <link rel="stylesheet" href="path/to/main.css">
    </head>
    ```

  * 导入样式

    指在`CSS类型文件`中通过`@import`导入其他样式。

    导入样式其实与`外部样式`很相似，在`HTML`初始化时，会被导入到文件中成为文件的一部分。对于多个网页的公有样式，可将它们抽离出来，再通过`@import`导入样式到这些网页的`css文件`中。

    ```html
    <head>
      <style>
      	@import url("path/to/common.css");
      </style>
    </head>
    ```

    ```css
    @import url("path/to/common.css");
    ```

  `内联样式`直接作用在节点上，因此优先级别最高；

  `内嵌样式`附属于`html文件`的解析而解析，因此优先级别跟着`内联样式`；

  `外部样式`需加载完毕才能解析，因此优先级别跟着`内嵌样式`；

  `导入样式`作用于`内嵌样式`或`外部样式`中，因此优先级别跟着`外部样式`。

#### 权重

进入文件中所有样式都使用不同选择器声明，那如何区分它们的优先级别？

选择器有着明显不可逾越的等级制度，可将其划分为六个权重等级。每个等级间的优先级别差距不可逾越，这些等级又称为权重。

以下从`直观权重`与`微观权重`两方面表述。简而言之，数字组成的值越大其权重就越大。

* 直观权重
  * 10000：`!important`
  * 1000：内联样式
  * 100：ID选择器
  * 10：类选择器、伪类选择器、属性选择器
  * 1：标签选择器、伪元素选择器
  * 0：通配选择器、兄弟选择器、后代选择器
* 微观权重
  * 1,0,0,0,0：`!important`
  * 0,1,0,0,0：内联样式
  * 0,0,1,0,0：ID选择器
  * 0,0,0,1,0：类选择器、伪类选择器（:）、属性选择器
  * 0,0,0,0,1：标签选择器、伪元素选择器（::）
  * 0,0,0,0,0：通配选择器、兄弟选择器、后代选择器

`直观权重`与`微观权重`只是表达方式不同，但实际意义一样。使用公式可表达为以下形式：

`!important` > 内联样式 > ID选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 标签选择器 = 伪元素选择器 > 通配选择器 = 兄弟选择器 = 后代选择器

#### 计算

认识了优先级别的特性与权重，可通过它们计算出以下常见场景的样式：

* 优先级别相同的规则使用最后出现的规则

* 优先级别无视节点在DOM树中的距离

  例子：

  ```html
  <div class="bruce flex-ct-x">
  	<h1>I am JowayYoung
  </div>
  ```

  ```css
  html h1 {
      color: #f66;
  }
  body h1 {
      color: #66f;
  }
  ```

  虽然`html`包着`body`，但根据`就近原则`，所以`h1`的颜色最终会显示`#66f`

* 不同规则作用于相同节点，使用优先级别最高的规则

* `:not()`不参与优先级别的计算

  `:not()`在优先级别计算中不会被看作`伪类`，但会把`:not()`中的选择器当作普通选择器计算。简而言之，忽略`:not()`，其他伪类照常参与优先级别计算。

通过上述场景可得到以下规则：

* 规则的权值不同时，权值高的规则优先
* 规则的权值相同时，后定义的规则优先
* 属性后面追加`!important`时，规则无条件绝对优先



### 长度单位

粗糙的干活可能只需`px`和`%`两个长度单位。

随着终端设备分辨率的多样性提高，`CSS`衍生出越来越多的长度单位，灵活结合这些长度单位能为网页的布局方案提供更多可能性。

| 单位 | 定义        | 类型     | 描述                                                         |
| ---- | ----------- | -------- | ------------------------------------------------------------ |
| px   | 像素        | 绝对单位 |                                                              |
| pt   | 点          | 绝对单位 | 1pt = 1/72 in                                                |
| pc   | 派          | 绝对单位 | 1pc = 12 pt                                                  |
| mm   | 毫米        | 绝对单位 |                                                              |
| cm   | 厘米        | 绝对单位 |                                                              |
| in   | 英寸        | 绝对单位 | 1in = 96px = 2.54cm                                          |
| %    | 百分比      | 相对单位 | 相对父节点尺寸，宽度相应，高度不一定相应                     |
| em   | 字母M的宽度 | 相对单位 | 相对当前节点字体（em作为font-size的单位时以父元素为准，作为padding等属性单位时，以当前元素font-size为准） |
| rem  | 字母M的宽度 | 相对单位 | 相对根节点字体                                               |
| ch   | 数字0的宽度 | 相对单位 | 相对当前节点字体                                             |
| ex   | 字母x的宽度 | 相对单位 | 相对当前节点字体                                             |
| vw   | 1%视窗宽度  | 相对单位 | 相对视窗                                                     |
| vh   | 1%视窗高度  | 相对单位 | 相对视窗                                                     |
| vmin | vw/vh最小值 | 相对单位 | 相对视窗                                                     |
| vmax | vw/vh最大值 | 相对单位 | 相对视窗                                                     |

这么多单位，要如何区别？首先要明确一点，那就是`屏幕分辨率`。

#### 屏幕分辨率

指横纵向中的像素点数，单位是`px`。

`屏幕分辨率`确定计算机屏幕中能显示多少信息，以水平与垂直像素衡量。

在屏幕尺寸一样的情况下，`屏幕分辨率`越低在屏幕中显示的像素越少，单个像素尺寸也较大，`屏幕分辨率`越高在屏幕中显示的像素越多，单个像素尺寸也较小。

`屏幕分辨率`就是屏幕中显式的像素个数，分辨率`1920 x 1080`意味着水平方向含有1920个像素点，垂直方向含有1080个像素点。在屏幕尺寸一样的情况下，`屏幕分辨率`越高，显示效果越细腻。

在同一网页中以`px`作为长度单位时，在不同`屏幕分辨率`中显示的大小可能不同。在`低屏幕分辨率`中像素较大，显示的网页元素也偏大偏模糊。实际上所有单位无论是绝对单位还是相对单位，最终都会转化为`px`在屏幕中显示，因此在设计与开发时都以`px`为准。

#### em与rem的区别

`em`与`rem`是移动端布局中特有的长度单位，两者的后缀都一样。`rem`全称是`root em`，指相对根节点作为参考的长度单位。

* em：当前节点字体宽度（一个M的宽度）
* rem：默认字体宽度（一个M的宽度）

两者区别：`em`以当前节点字体宽度作为参考，`rem`以根节点`<html>`字体宽度作为参考，默认是`16px`。

很多同学错误地以为`em`是根据父节点作为参考，实际上是当前节点继承了父节点的属性后产生的错觉。

`em`与`rem`都是很灵活且可扩展的长度单位，由浏览器自行转换为`px`，具体取决于设计图中的字体大小。

针对移动端，作者通常结合`JS`根据屏幕宽度与设计图宽度的比例动态声明`<html>`的`font-size`，以`rem`为长度单位声明所有节点的几何属性，这样就能做到很多移动设备的网页兼容，兼容出入较大的地方再通过`媒体查询`做特别处理。

```javascript
// width： 设计图宽度
// document.documentElement.clientWidth 文档宽度（不包含滚动条宽度）
// window.innerWidth 视口宽度（包含滚动条宽度）
// window.visualViewport.width 不包含滚动条宽度
function AutoResponse(width = 750) {
  const target = document.documentElement;
  if (target.clientWidth >= 600) {
    target.style.fontSize = "80px";
  } else {
    target.style.fontSize = `${target.clientWidth / width * 100}px`;
  }
}
AutoResponse();
```

前提还需在`<html>`中声明以下代码，阻止用户缩放屏幕。

```html
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, minimum-scale=1, maximum-scale=1">
```

#### 视窗比例单位

在`CSS3`中增加了四个与`viewport`相关的长度单位。随着时间推移，目前很多浏览器对这些长度单位都有较好的兼容，这也是未来最建议在伸缩方案中使用的长度单位。

* 1vw：1%视窗宽度
* 1vh：1%视窗高度
* 1vmin：1%视窗宽度与1%视窗高度中最小者
* 1vmax：1%视窗宽度与1%视窗高度中最大者

视窗宽高在`JS`中分别对应`window.innerWidth`与`window.innerHeight`。

若不考虑低版本浏览器的兼容，完全可用一行代码秒杀所有移动端的伸缩方案。

```css
/* 基于UI width=750px DPR=2的网页 */
html {
  font-size: calc(100vw / 7.5);
}
```

这段代码可代替上述那段`JS代码`。

100vw/750 * 100 = 10000vw / 750 = 100vw / 7.5